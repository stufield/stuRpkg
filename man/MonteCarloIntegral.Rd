% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MonteCarloIntegral.R
\name{MonteCarloIntegral}
\alias{MonteCarloIntegral}
\title{Monte-Carlo Integration}
\usage{
MonteCarloIntegral(n = 10000, interval, FUN, force = FALSE,
  quick = TRUE, plot = FALSE)
}
\arguments{
\item{n}{Integer. How many points to use in the estimation. Defaults to 10000}

\item{interval}{Range of "x" over which the function should be evaluated}

\item{FUN}{The function to integrate. Can be any function}

\item{force}{Logical. Should a brute force method be used to find
the maximum of "y". This can sometimes be useful to avoid missing
the global maximum via \code{\link[stats]{optimize}}, but is slower
since many points along the function are independently evaluated}

\item{quick}{Logical. Should a vectorized implementation be used?}

\item{plot}{Logical. Should the simulation be plotted upon completion?
This option is ignored if \code{quick = FALSE}.}
}
\value{
Numeric estimation of the integral (area below the curve). If
\code{quick = FALSE}, a real-time plot of the function with randomly added
points colored by above and below the function is generated
}
\description{
Solving indefinite integrals via Monte-Carlo Monte-Carlo integration
of any unknown function of "x" via simulation. Calculates the area under
the curve by picking numerous points and deciding if that point falls
above or below the curve. This demo shows the method of Monte-Carlo
and how it can be used to estimate the integral (area under a function)
over a given interval of "x". Simulation mimics a random dart thrown
on a dartboard style algorithm.
}
\details{
When \code{quick = TRUE}, a quicker implementation is used which uses
vectorized random number generation and optional plotting (plotting
is slow). This vectorized version is >100x faster than the "slow" version
when plotting turned off.
}
\note{
This demo is for students to visually see how the Monte-Carlo
Integration works. Includes an iteration counter & a run time indicator.
}
\examples{
# set objective function to optimize

mysteryFun <- function(x) {
  20*dnorm(x, mean=-1, sd=5) +
    ifelse(x > -1.1, 
    6*dgamma(x=x+1,shape=2,scale=0.5), 
    1.5*dgamma(x=-x,shape=5,scale=0.2)) + 
    2*dgamma(x=2.75-x, shape=3, scale=0.25)
}

# compare quick=T vs. quick=F

\dontrun{
MonteCarloIntegral(n = 10000, interval = c(-2.98, 2.98), FUN = mysteryFun, quick = FALSE)
MonteCarloIntegral(n = 10000, interval = c(-2.98, 2.98), FUN = mysteryFun)
}

# 1000 simulations
head(MC_sims)
mean(MC_sims)

# Plot histogram of 1000 estimates
hist(MC_sims, col = "gray75", prob = TRUE, xlab = "Area", main = "", breaks = 15)
box()
lines(density(MC_sims))
lines(density(MC_sims, adjust = 1.75), lty = "dotted", col = 2)
par <- density(MC_sims)$x[which.max(density(MC_sims)$y)]
abline(v = par, col = 4, lty = "dotted")
legend("topleft", legend=sprintf("Area Est ~ 0.3\%f", par), 
       bg = "gray75", cex = 0.75)

# check that histogram sums to 1
H <- hist(MC_sims, plot = FALSE)
print(sum((H$breaks[2]-H$breaks[1]) * H$density), digits = 10)
}
\references{
put references to the literature/web site here
}
\seealso{
\code{\link{optimize}}
}
\author{
Stu Field, William Black IV!
}
\keyword{~kwd1}
\keyword{~kwd2}
